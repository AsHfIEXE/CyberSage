# CyberSageV2/tools/exploit.py
from .common import TOOL_CONFIG, get_tool_path, run_tool_command, logger
from .common import db_log_tool_run, db_store_structured_result
import json

def run_exploit_checks(target_info, vulnerabilities_found_data, scan_id, db_conn):
    logger.info(f"Exploit check module initiated for target: {target_info} (Scan ID: {scan_id})")
    exploit_tool_name = TOOL_CONFIG.get("exploit_tools", {}).get("cve_exploitation", ["searchsploit"])[0]
    tool_executable = get_tool_path(exploit_tool_name)
    exploit_references = []
    tool_status = "skipped" # Default status

    if not tool_executable or exploit_tool_name != "searchsploit":
        logger.warning(f"Searchsploit not configured or not selected. Exploit lookup skipped.")
        db_log_tool_run(db_conn,scan_id,"exploit_module_overall","config_error_searchsploit","",f"Searchsploit not configured for {target_info}",target_info)
        return {"status": tool_status, "references_found": exploit_references}

    keywords_to_search = set()
    try:
        # Ensure vulnerabilities_found_data is a list of dicts
        vulns_list = vulnerabilities_found_data if isinstance(vulnerabilities_found_data, list) else []
        
        for vuln in vulns_list[:10]: # Limit searches to avoid too many calls
            if not isinstance(vuln, dict): continue
            
            info = vuln.get('info', {}) # For Nuclei-like structures
            name = info.get('name', '')
            cve_ids = info.get('classification', {}).get('cve-id', [])
            if isinstance(cve_ids, str) : cve_ids = [cve_ids] # Ensure it's a list
            
            # For other tool structures (e.g., Dalfox, Nikto if normalized into all_vuln_findings_for_ai)
            if not name and vuln.get('type'): name = vuln.get('type') # Dalfox type, Nikto ID etc.
            if not cve_ids and vuln.get('data') and isinstance(vuln.get('data'), dict): # Deeper check
                 cve_ids_inner = vuln['data'].get('info',{}).get('classification',{}).get('cve-id',[])
                 if isinstance(cve_ids_inner, str): cve_ids_inner = [cve_ids_inner]
                 cve_ids.extend(cve_ids_inner)

            if name: # Extract keywords from name/type
                name_parts = re.split(r'[\s\-_:]+', name) # Split by common delimiters
                for part in name_parts:
                    if len(part) > 3 and part.isalpha(): keywords_to_search.add(part.lower())
            for cve in cve_ids: 
                if cve and isinstance(cve, str) : keywords_to_search.add(cve)

    except Exception as e: logger.error(f"Error parsing vulnerabilities for exploit search keywords: {e}")

    search_terms_used = list(keywords_to_search)[:5] # Search up to 5 unique keywords/CVEs
    if not search_terms_used: 
        logger.info("No suitable keywords/CVEs extracted for Searchsploit."); 
        tool_status = "no_keywords"
    
    all_searchsploit_runs_ok = True
    for term in search_terms_used:
        if not term or len(term) < 3 : continue 
        logger.info(f"SearchSploit: Looking up exploits for: '{term}' (related to {target_info})")
        # Use --json flag
        cmd_searchsploit = [tool_executable, "--json", term.strip()] 
        
        ss_stdout, ss_stderr, ss_ret_code = run_tool_command(cmd_searchsploit, "searchsploit_lookup", term, timeout_seconds=60)
        
        current_run_status = "failed"
        if ss_ret_code == 127 or ("command not found" in ss_stderr.lower()): current_run_status = "config_error_not_found"
        elif ss_ret_code == 0 and ss_stdout:
            try:
                search_results_json = json.loads(ss_stdout)
                if search_results_json and search_results_json.get("RESULTS_EXPLOIT"):
                    current_run_status = "success_found_exploits"
                    for exploit_entry in search_results_json["RESULTS_EXPLOIT"][:3]: # Log first 3 found for this term
                        if not isinstance(exploit_entry, dict): continue
                        exploit_info = {"lookup_term": term, "title": exploit_entry.get("Title"), "path": exploit_entry.get("Path"), "type": exploit_entry.get("Type"), "platform": exploit_entry.get("Platform"), "edb_id": exploit_entry.get("EDB-ID")}
                        exploit_references.append(exploit_info)
                        db_store_structured_result(db_conn, scan_id, "searchsploit_lookup", "exploit_reference", exploit_info, target_info)
                    logger.info(f"SearchSploit found {len(search_results_json['RESULTS_EXPLOIT'])} exploits for '{term}'.")
                elif search_results_json and not search_results_json.get("RESULTS_EXPLOIT"):
                    current_run_status = "success_no_exploits"
                    logger.info(f"SearchSploit found no exploits for '{term}'.")
                else: # Valid JSON but unexpected structure
                    current_run_status = "failed_parsing_json_structure"
                    logger.warning(f"Searchsploit JSON for '{term}' has unexpected structure.")
            except json.JSONDecodeError:
                current_run_status = "failed_parsing_json_decode"
                logger.warning(f"Searchsploit output for '{term}' not valid JSON: {ss_stdout[:100]}")
        elif ss_ret_code == 0: current_run_status = "success_empty_output"
        
        if current_run_status.startswith("failed"): all_searchsploit_runs_ok = False
        db_log_tool_run(db_conn, scan_id, f"searchsploit_lookup_{term}", current_run_status, ss_stdout, ss_stderr, target_info)

    if exploit_references: tool_status = "success_references_found"
    elif search_terms_used and all_searchsploit_runs_ok : tool_status = "success_no_references_found"
    elif not search_terms_used : tool_status = "no_keywords_to_search" # If search was skipped
    else: tool_status = "completed_with_errors" # If some searches failed

    final_msg = f"Exploit lookup module completed. Found {len(exploit_references)} potential references. Status: {tool_status}"
    logger.info(final_msg)
    db_log_tool_run(db_conn, scan_id, "exploit_module_overall", tool_status, final_msg, "", target_info)
    return {"status": tool_status, "references_found": exploit_references}